// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AirCon air con
//
// swagger:model AirCon
type AirCon struct {

	// range
	Range *AirConRange `json:"range,omitempty"`

	// temp unit
	// Enum: [ c f]
	TempUnit string `json:"tempUnit,omitempty"`
}

// Validate validates this air con
func (m *AirCon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTempUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AirCon) validateRange(formats strfmt.Registry) error {
	if swag.IsZero(m.Range) { // not required
		return nil
	}

	if m.Range != nil {
		if err := m.Range.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range")
			}
			return err
		}
	}

	return nil
}

var airConTypeTempUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["","c","f"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		airConTypeTempUnitPropEnum = append(airConTypeTempUnitPropEnum, v)
	}
}

const (

	// AirConTempUnitEmpty captures enum value ""
	AirConTempUnitEmpty string = ""

	// AirConTempUnitC captures enum value "c"
	AirConTempUnitC string = "c"

	// AirConTempUnitF captures enum value "f"
	AirConTempUnitF string = "f"
)

// prop value enum
func (m *AirCon) validateTempUnitEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, airConTypeTempUnitPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AirCon) validateTempUnit(formats strfmt.Registry) error {
	if swag.IsZero(m.TempUnit) { // not required
		return nil
	}

	// value enum
	if err := m.validateTempUnitEnum("tempUnit", "body", m.TempUnit); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this air con based on the context it is used
func (m *AirCon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRange(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AirCon) contextValidateRange(ctx context.Context, formats strfmt.Registry) error {

	if m.Range != nil {
		if err := m.Range.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AirCon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AirCon) UnmarshalBinary(b []byte) error {
	var res AirCon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AirConRange air con range
//
// swagger:model AirConRange
type AirConRange struct {

	// fixed buttons
	FixedButtons []ACButton `json:"fixedButtons"`

	// modes
	Modes *AirConRangeModes `json:"modes,omitempty"`
}

// Validate validates this air con range
func (m *AirConRange) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFixedButtons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AirConRange) validateFixedButtons(formats strfmt.Registry) error {
	if swag.IsZero(m.FixedButtons) { // not required
		return nil
	}

	for i := 0; i < len(m.FixedButtons); i++ {

		if err := m.FixedButtons[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "fixedButtons" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "fixedButtons" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AirConRange) validateModes(formats strfmt.Registry) error {
	if swag.IsZero(m.Modes) { // not required
		return nil
	}

	if m.Modes != nil {
		if err := m.Modes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this air con range based on the context it is used
func (m *AirConRange) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFixedButtons(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AirConRange) contextValidateFixedButtons(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FixedButtons); i++ {

		if err := m.FixedButtons[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "fixedButtons" + "." + strconv.Itoa(i))
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "fixedButtons" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *AirConRange) contextValidateModes(ctx context.Context, formats strfmt.Registry) error {

	if m.Modes != nil {
		if err := m.Modes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AirConRange) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AirConRange) UnmarshalBinary(b []byte) error {
	var res AirConRange
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AirConRangeModes air con range modes
//
// swagger:model AirConRangeModes
type AirConRangeModes struct {

	// auto
	Auto *AirConRangeMode `json:"auto,omitempty"`

	// blow
	Blow *AirConRangeMode `json:"blow,omitempty"`

	// cool
	Cool *AirConRangeMode `json:"cool,omitempty"`

	// dry
	Dry *AirConRangeMode `json:"dry,omitempty"`

	// warm
	Warm *AirConRangeMode `json:"warm,omitempty"`
}

// Validate validates this air con range modes
func (m *AirConRangeModes) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuto(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCool(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWarm(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AirConRangeModes) validateAuto(formats strfmt.Registry) error {
	if swag.IsZero(m.Auto) { // not required
		return nil
	}

	if m.Auto != nil {
		if err := m.Auto.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "auto")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "auto")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) validateBlow(formats strfmt.Registry) error {
	if swag.IsZero(m.Blow) { // not required
		return nil
	}

	if m.Blow != nil {
		if err := m.Blow.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "blow")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "blow")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) validateCool(formats strfmt.Registry) error {
	if swag.IsZero(m.Cool) { // not required
		return nil
	}

	if m.Cool != nil {
		if err := m.Cool.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "cool")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "cool")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) validateDry(formats strfmt.Registry) error {
	if swag.IsZero(m.Dry) { // not required
		return nil
	}

	if m.Dry != nil {
		if err := m.Dry.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "dry")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "dry")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) validateWarm(formats strfmt.Registry) error {
	if swag.IsZero(m.Warm) { // not required
		return nil
	}

	if m.Warm != nil {
		if err := m.Warm.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "warm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "warm")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this air con range modes based on the context it is used
func (m *AirConRangeModes) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuto(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlow(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCool(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDry(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWarm(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AirConRangeModes) contextValidateAuto(ctx context.Context, formats strfmt.Registry) error {

	if m.Auto != nil {
		if err := m.Auto.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "auto")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "auto")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) contextValidateBlow(ctx context.Context, formats strfmt.Registry) error {

	if m.Blow != nil {
		if err := m.Blow.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "blow")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "blow")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) contextValidateCool(ctx context.Context, formats strfmt.Registry) error {

	if m.Cool != nil {
		if err := m.Cool.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "cool")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "cool")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) contextValidateDry(ctx context.Context, formats strfmt.Registry) error {

	if m.Dry != nil {
		if err := m.Dry.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "dry")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "dry")
			}
			return err
		}
	}

	return nil
}

func (m *AirConRangeModes) contextValidateWarm(ctx context.Context, formats strfmt.Registry) error {

	if m.Warm != nil {
		if err := m.Warm.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("range" + "." + "modes" + "." + "warm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("range" + "." + "modes" + "." + "warm")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AirConRangeModes) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AirConRangeModes) UnmarshalBinary(b []byte) error {
	var res AirConRangeModes
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
